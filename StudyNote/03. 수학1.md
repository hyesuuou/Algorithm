수학1 내용 - 나머지연산, 최대공약수, 최소공배수, 소수, 팩토리얼

## Modular Arithmetic 나머지연산

% —> mod

1. (A+B) % M = ((A%M) + (B%M)) % M
2. (AxB) mod M = ((A mod M) x (B mod M)) mod M
3. (A-B) mod M = ((A mod M) - (B mod M) + M) mod M
4. 나눗셈은 성립하지 않는다.

뺄셈에서 +M을 더해주는 이유는 mod 연산 결과가 음수일 수 있기 때문에 양수로 만들어 주기 위함이다.  (a%c - b%c) 가 -c < (a%c - b%c) < c 이므로 모든 변에 + c 를 해서 0보다 크게 만들어준다.

---
## Greatest Common Divisor - GCD 최대공약수
최대공약수는 **두 수 A와 B가 주어졌을 때 이 둘의 공통된 약수 중에서 가장 큰 정수**를 말한다. 최대공약수가 1인 두 수는 서로소(Coprime) 이라고 한다.

### 구하는 방법 1 - 2부터 min(A,B)까지 나누어보기

```c
int g = 1;
for (int i=2; i<= min(a, b); i++){
	if (a%i ==0 && b%i ==0){
		g = i;
	}
}
```

### 구하는 방법 2 - 유클리드 호제법 이용

유클리드 호제법 (Eucldean algorithm)은 a를 b로 나눈 나머지를 r이라고 할 때, GCD (a.b) = GCD (b,r) 과 같으며 r이 0이면 그 때의 b가 최대공약수라는 것을 이용하는 방법이다.

1. **GCD (a,b) = GCD (b, a%b) (if b>0)**
2. **GCD (a,0) = a**

- 재귀함수를 이용한 구현

    ```c
    int gcd(int a, int b){
    	if (b==0){
    		return a;
    	}
    	else {
    		return gcd(b, a%b);	
    	}
    }
    ```

- 재귀함수가 아닌 반복문을 이용한 구현

    ```c
    int gcd(int a, int b){
    	while (b!=0){
    		int r = a%b;
    		a = b;
    		b = r;
    	}
    	return a;
    }
    ```
    
---
## Least Common Multiple - LCM 최소공배수
최소공배수는 **두 수의 공통된 배수 중에서 가장 작은 정수**를 의미하며, 최대공약수를 응용해서 구할 수 있다. 

- **AxB = GCD x LCM 이므로 LCM = AB/GCD**


    
