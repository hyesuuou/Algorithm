수학1 내용 - 나머지연산, 최대공약수, 최소공배수, 소수, 팩토리얼

## Modular Arithmetic 나머지연산

% —> mod

1. (A+B) % M = ((A%M) + (B%M)) % M
2. (AxB) mod M = ((A mod M) x (B mod M)) mod M
3. (A-B) mod M = ((A mod M) - (B mod M) + M) mod M
4. 나눗셈은 성립하지 않는다.

뺄셈에서 +M을 더해주는 이유는 mod 연산 결과가 음수일 수 있기 때문에 양수로 만들어 주기 위함이다.  (a%c - b%c) 가 -c < (a%c - b%c) < c 이므로 모든 변에 + c 를 해서 0보다 크게 만들어준다.

---
## Greatest Common Divisor - GCD 최대공약수
최대공약수는 **두 수 A와 B가 주어졌을 때 이 둘의 공통된 약수 중에서 가장 큰 정수**를 말한다. 최대공약수가 1인 두 수는 서로소(Coprime) 이라고 한다.

### 구하는 방법 1 - 2부터 min(A,B)까지 나누어보기

```c
int g = 1;
for (int i=2; i<= min(a, b); i++){
	if (a%i ==0 && b%i ==0){
		g = i;
	}
}
```

### 구하는 방법 2 - 유클리드 호제법 이용

유클리드 호제법 (Eucldean algorithm)은 a를 b로 나눈 나머지를 r이라고 할 때, GCD (a.b) = GCD (b,r) 과 같으며 r이 0이면 그 때의 b가 최대공약수라는 것을 이용하는 방법이다.

1. **GCD (a,b) = GCD (b, a%b) (if b>0)**
2. **GCD (a,0) = a**

- 재귀함수를 이용한 구현

    ```c
    int gcd(int a, int b){
    	if (b==0){
    		return a;
    	}
    	else {
    		return gcd(b, a%b);	
    	}
    }
    ```

- 재귀함수가 아닌 반복문을 이용한 구현

    ```c
    int gcd(int a, int b){
    	while (b!=0){
    		int r = a%b;
    		a = b;
    		b = r;
    	}
    	return a;
    }
    ```
    
---
## Least Common Multiple - LCM 최소공배수
최소공배수는 **두 수의 공통된 배수 중에서 가장 작은 정수**를 의미하며, 최대공약수를 응용해서 구할 수 있다. 

- **AxB = GCD x LCM 이므로 LCM = AB/GCD**

---
## Prime Number 소수
어떤 수의 약수과 1과 자기 자신 뿐일때, 그 수를 소수 (prime number)라고 한다. **소수가 되려면 2보다 크거나 같고, n-1보다 작거나 같은 자연수로 나누어 떨어지면 안된다.**

### 1. 어떤 수 N이 소수인지 아닌지 판별하는 방법

- **소수의 정의**를 이용하여 구하면 된다.

```c
// 소수면 true, 소수가 아니면 false를 반환
// 시간복잡도 O(N)
bool prime(int n) {
	if (n<2 ){
		return false;
	}
	for (int i=2; i<=n-1; i++) {
		if (n%i == 0){
			return false;
		}
	}
	return true;
}
```

- 소수가 되려면 **2보다 크거나 같고, N/2보다 작거나 같은 자연수로 나누어 떨어지지 않아야 한다는 성질을 이용한다.** 예를들어, 12의 약수는 1,2,3,4,6,12 인데, 1 다음수가 바로 2이기 때문에 약수는 무조건 N/2이거나 그보다 작아야 한다는 것을 알 수 있다. (N/2+1) ~ (N-1) 사이에는 약수가 있을 수 없다.

    ```c
    // 시간복잡도 O(n/2) = O(n)
    bool prime (int n) { 
    	if (n<2){
    		return false;
    	}
    	for (int i=2; i<=n/2; i++) {
    		if (n%i ==0){
    			return false;
    		}
    	}
    	return true;
    }
    ```

     

- 소수가 되려면 2**보다 크거나 같고, 루트 N보다 작거나 같은 자연수로 나누어 떨어지면 안된다는 성질을 이용**한다. 루트N * 루트N = N 이므로 약수의 중간 수는 항상 루트N이거나 루트N보다 작다. 약수는 가장 가운데 수인 루트N을 제외하면 짝을 이루기 때문에 루트N이하에서 2보다 큰 약수가 존재하면 소수가 될 수 없다. 따라서 입력된 값 N이 소수인지 알아보려면, 루트N까지만 검사하면 된다. (그러면 약수가 있는지 없는지 판단할 수 있다.) 컴퓨터에서는 정수 계산을 하기 위해 i*i≤N으로 조건을 계산한다.

    ```c
    // 시간복잡도 : O(루트n)
    bool prime(int n){
        if (n<2){
            return false;
        }
        for (int i=2; i*i<=n; i++){
            if (n % i == 0){
                return false;
            }
        }
        return true;
    }
    ```

    → 하나의 수가 소수인지 아닌지 알아보기 위해서는 시간복잡도 O(루트n)이 필요하다. 따라서 1부터 N까지 소수를 모두 찾아내는 것은 O(n루트n) 이 필요하다. (굉장히 큰 시간)

### 2. N보다 작거나 같은 모든 자연수 중에서 소수를 찾아내는 방법

1부터 N까지 범위 안에 들어가는 모든 소수를 구하기 위해서는 **에라토스테네스의 체**를 이용하면된다. 에라토스테네스의 체는 다음과 같은 방법으로 구한다.

1. 2부터 N까지 모든 수를 쓴다.
2. 지워지지 않은 수 중에서 가장 작은 수를 찾는다.
3. 그 수는 소수이며, 그 수의 배수를 모두 지운다.
4. 2~3을 반복한다.
5. 남아있는 수가 모두 소수이다.

만약 N=100 이라서 1 ~ 100 사이의 모든 소수를 구하려고 한다면, **11x11은 이미 100을 넘기 때문에 2,3,5,7 부분만 과정2~3을 반복해서 수행하면 된다.** 그 이유를 예를 들어 설명하자면, 2에서 이미 2*3, 2*5 를 모두 수행해서 지우기 때문에 3*2, 5*2 는 수행할 필요가 없고 3은 3*3부터, 5는 5*5부터 수행하면 된다. 따라서 11도 11*11 부터 수행하면 되는데 이미 11*11은 100을 넘어버리므로 계산할 필요가 없는 것이다.

```cpp
int prime[100]; //소수저장
int pn=0; // 소수의 개수
bool check[101]; //지워지면 true
int n=100;  // 100까지 소수
for (int i=2; i<=n; i++){
    if (check[i]==false){   // 지워지지 않았으면 
        prime[pn++] = i;    // 그 수는 소수이고
        for (int j=i*i; j<=n ; j+=i){   // 그 소수의 배수들을 다 조사
            check[j] = true;    // 배수들은 지워짐
        }
    }
}
```
    
### 3. GoldBach's conjecture 골드바흐의 추측

1. 2보다 큰 모든 짝수는 두 소소의 합으로 표현 가능하다.
2. 5보다 큰 모든 홀수는 세 소수의 합으로 표현 가능하다.

아직 전체가 증명된 것은 아니고 10^18 이하에서 참인것이 증명되어 있다.

### 4. 6n+1, 6n+5(6n-1)

모든 정수는 6n+1의 형태로 나타낼 수 있다. 6n+2 ~4는 2,3 으로 나눠지므로 소수가 아니다.

---
## Factorial 팩토리얼
N! = 1 x 2 x 3 x ... x N이며, 매우 큰 값이다.

### 팩토리얼의 0의 개수

N! 의 결과에서 0이 몇 개 인지 알아내는 문제로, 10 = 2x5이므로 주어진 수를 소인수분해해서 5의 개수를 구한다. (2의 수보다 5의 수가 작을 수밖에 없다.)

### 조합 0의 개수

nCm 의 0의 개수를 구하는 문제이며, 항상 2가 더 많은 팩토리얼과는 달리 2와 5중에 뭐가 더 많을지 모르기 때문에 둘의 개수를 동시에 세어줘야 한다.
