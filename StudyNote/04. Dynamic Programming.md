## Dynamic Programming 동적계획법
큰 문제를 작은 문제로 나누는 방법은 **Dynamic Programming** 과 **분할정복(Divide&Conquer)** 이 있다. 이 **두 가지 방법의 차이는 하나의 큰 문제를 여러개의 작은 문제로 나누었을 때, 그 작은 문제가 중복되면 Dynamic programming, 아니면 분할정복**이다. Dynamic Programming이라는 이름은 거창한 뜻이 있을 것 같지만 사실 아무런 뜻이 없고, 한글로 직역하면 그냥 동적 계획법이다.

아래의 **두 가지 조건**을 모두 만족해야만 Dynamic Programming 으로 풀 수 있다.

1. Overlapping Subproblem (겹치는 부분문제)
2. Optimal Substructure (최적부분구조)

### 1. Overlapping Subproblem

- **큰 문제와 작은 문제를 같은 방법으로 풀 수 있으며, 문제를 작은 문제로 쪼갤 수 있다.**

    여기서 작은 문제와 큰 문제는 상대적인 문제이다. 예를 들어 N번째 피보나치 수를 구하기 위해 N-1 과 N-2번째 피보나치수를 구한다면 큰 문제는 N번째 피보나치 수 구하기가, 작은문제는 N-1과 N-2번째 피보나치 수 구하기가 된다. 하지만 N-1번째 피보나치 수를 구하기 위해 N-2와 N-2번째 피보나치수를 구한다면, 큰 문제는 N-1번째 피보나치수 구하기가 되고, 작은 문제는 N-2와 N-3번째 피보나치 수 구하기가 되는 것이다.

    ex) 피보나치수 F_n = F_{n-1} + F_{n-2}  (n≥2)

### 2. Optimal Substructure

- **문제의 정답을 작은 문제의 정답에서 구할 수 있다**.

    피보나치수에서 N번째 피보나치 수를 구하는 것을 예로 들어 보겠다. N번째 피보나치 수를 구하기 위해서는 N-1 번째 피보나치 수를 구하고, N-2번째 피보나치 수를 구해서 더해야 한다. 따라서 이는 문제의 정답을 작은 문제의 정답을 합하여 구하고 있는 것이다. N-1번째, N-2번째, N-3번째... 피보나치수 구하기도 이와 마찬가지이다.

- Optimal Substructure을 만족하면, **문제의 크기에 관계 없이 어떤 한 문제의 정답은 일정하다. →** 같은 문제는 구할 때마다 정답이 같으므로 **, 정답을 배열에 메모해놓고, 빨리 가져다 써서 시간을 단축한다. (Memorization!!)** 

    5번째 피보나치를 구한다고 하면, 4번째와 3번째를 구해야 한다. 4번째를 구하기 위해서는 3번째와 2번째를 더해야 하고, 3번째를 구하기 위해서는 2번째와 1번째를 더해야 한다. 이때 2번째는 4번째를 구할때도 사용되고, 3번째를 구할 때에도 사용된다. 따라서 이 경우 모두 계산하는 것이 아니라, 한번만 계산하고 중복되는 결과는 저장했다가 필요할때마다 가져다가 쓰면 된다.

   
    - 저장하지 않는 경우 → 시간복잡도 O(2^n)

    ```cpp
    int fibonacci(int n){
        if (n <= 1)[
            return n;
        ]
        else {
            return fibonacci(n-1) + fibonacci(n-2);
        }
    }
    ```

    - 저장하는 경우 → 시간복잡도 O(N)

    ```cpp
    // 모든 문제를 한번씩 푼다. -> 문제의 개수(N)*문제 1개를 푸는 시간(함수의 시간복잡도 1) 
    // 총 시간복잡도 O(N)
    int memo[100];
    int fibonacci (int n){
        if (n <= 1){
            return n;
        }
        else {
            if (memo[n] > 0){       // 계산된 값이 존재하면 바로 찾아서 리턴하기 
                return memo[n];
            }
            memo[n] = fibonacci(n-1) + fibonacci(n-2); // 없으면 직접 계산 하고 저장함
            return memo[n];
        }
    }
    ```
    
---
## Dynamic Programming 의 구현방식
Dynamic Programming 의 구현방식에는 **Top-down** 방식과 **Bottom-up** 방식이 있다. 이 둘의 시간 차이는 알 수 없다. 

### Top - down 방식

**재귀호출**을 사용하는 방식이다.

1. 큰 문제를 작은 문제로 나눈다.
2. 작은 문제를 푼다.
3. 작은 문제를 풀었으니, 이제 큰 문제를 푼다.

```markdown
<fibonacci(n) 문제 풀이>
1. fibonacci(n) -> fibonacci(n-1)과 fibonacci(n-2)로 나눈다.
2. fibonacci(n-1)과 fibonacci(n-2)를 호출해 문제를 푼다.
3. fibonacci(n-1)과 fibonacci(n-2)의 값을 더해 문제를 푼다.
```

### Bottom-up 방식

**반복문**을 사용하는 방식이다.

1. 문제를 크기가 작은 문제부터 차례대로 푼다. (i=2)
2. 문제의 크기를 조금씩 크게 만들면서 문제를 푼다. (i++)
3. 작은 문제를 풀면서 왔으므로, 큰 문제는 항상 풀 수 있다.
4. 이를 반복하면, 가장 큰 문제를 풀 수 있다.

```cpp
// 시간복잡도 O(n)
int d[100];
int fibonacci(int n){
    d[0] = 0;
    d[1] = 1;
    for (int i=2; i<n; i++){
        d[i] = d[i-1] + d[i-2];
    }
    return d[n];
}
```

---
## Dynamic Programming 의 풀이법
1. 문제에서 구하려고 하는 답을 문장으로 나타낸다. (ex. N 번째 피보나치 수)
2. 문장안에 나와있는 변수의 개수만큼 메모하는 배열을 만든다. (top-down이면 재귀호출 인자의 개수)
3. 문제를 작은 문제로 나누고, 수식을 이용해서 문제를 표현한다. (점화식 !!!!)
